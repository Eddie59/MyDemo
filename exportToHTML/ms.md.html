<html>
<head>
<title>ms.md</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); font-weight: bold; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(169,183,198); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
ms.md</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">#</span><span class="s1">Java语言</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">final关键字</span><span class="s2"> 
</span><span class="s1">1，final关键字修饰基本类型，引用类型区别&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">2，final修饰类、方法的用法&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">3，final修饰方法的参数，参数如果为基本类型，为引用类型&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">4，被final修饰的变量一旦初始化完成，就不能再次给它赋值，所以对多线程是可见的</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">static关键字</span><span class="s2"> 
</span><span class="s1">1，说下类实例和对象实例&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">类实例 是加载进来的那个 Class 的实例，即用来创建对象的模板,对象实例 就是由模板创建出来的一个个实际的对象&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">例如类 A 由类加载器加载并初始后便有类实例 A.class，基于 A.class 创建的 a1, a2, a3, 它们的 a1.getClass</span><span class="s2">()</span><span class="s1">, a2.getClass</span><span class="s2">()</span><span class="s1">, a3.getClass</span><span class="s2">() </span><span class="s1">就是 A.class 类实例&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">2，引出static，static是定义类实例的成员，没有static是定义对象实例的成员&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">举例，比如一个Person类有两个变量，一个static修饰的name，一个没有static修饰的age变量，那么Person.Class.getFields</span><span class="s2">()</span><span class="s1">方法只有name变量&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">3，在多线程中，如果synchronized修饰的是static类型的方法，加锁的对象是类的class对象，和synchronized</span><span class="s2">(</span><span class="s1">this</span><span class="s2">)</span><span class="s1">是异步的&lt;br/&gt;</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">java中的hashcode和equal</span><span class="s2">()</span><span class="s1">方法</span><span class="s2"> 
</span><span class="s1">3，如果两个对象相同，那么它们的hashCode值一定要相同；如果两个对象的hashCode相同，它们并不一定相同；  </span><span class="s2"> 
</span><span class="s1">4，我们一般在覆盖equals的同时也要覆盖hashcode，让他们的逻辑一致，如果没有覆盖会出现什么情况？&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">举例，向HashSet&lt;Person&gt;中插入元素时，如果重写了Person的equals方法，用到了name属性，两个name属性一样的person，插入HashSet时，都能插入到HashSet，因为HashSet内部先得到元素的HashCode，找到元素的位置，两个对象的HashCode一定是不一样的，所以存放位置也不同，所以可以插入，这样两个元素比较时，返回true，但可以插入HashSet，HashSet是不允许为重复值的</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">创建线程的几种方法</span><span class="s2"> 
</span><span class="s1">1，实现Runable接口</span><span class="s2"> 
</span><span class="s1">2，继承Thread类</span><span class="s2"> 
</span><span class="s1">3，实现Callable接口，可以有返回值</span><span class="s2"> 
</span><span class="s1">4，线程池</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">线程的状态都有哪些</span><span class="s2"> 
</span><span class="s1">1，新建状态，没调用start</span><span class="s2">()</span><span class="s1">方法之前，和普通对象没有区别&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">2，调用start</span><span class="s2">()</span><span class="s1">后，进入就绪状态（runnable），系统分配cpu线程资源</span><span class="s2"> 
</span><span class="s1">3，得到cpu资源，进入运行状态</span><span class="s2">(</span><span class="s1">running</span><span class="s2">) 
</span><span class="s1">4.1，阻塞状态</span><span class="s2">(</span><span class="s1">blocked</span><span class="s2">) 
</span><span class="s1">4.2，等待状态</span><span class="s2">(</span><span class="s1">waiting</span><span class="s2">) 
</span><span class="s1">5，死亡状态</span><span class="s2"> 
![</span><span class="s1">线程状态转换</span><span class="s2">](</span><span class="s1">images/线程状态转换.png</span><span class="s2">) 
</span><span class="s1">几个小问题：</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">wait与join的区别&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">join</span><span class="s2">()</span><span class="s1">内部是利用了wait</span><span class="s2">()</span><span class="s1">，所以，它会释放锁，只不过它不用等待notify</span><span class="s2">()</span><span class="s1">/notifyAll</span><span class="s2">()</span><span class="s1">。它结束的条件是：1）等待时间到；2）目标线程已经run完（通过isAlive</span><span class="s2">()</span><span class="s1">来判断）。</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">wait与sleep的区别</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">怎样接受线程的返回值</span><span class="s2"> 
</span><span class="s1">1，说下使用的元素，Callable函数式接口，Future接口，FutureTask包装类，重点说下FutureTask继承的两个接口Future，Runnable&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">2，说下过程，看CallableDemo类&lt;br&gt;</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">线程同步的几种方式</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">synchronized</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">同步方法（1，同步static方法 2，同步普通方法，相当于同步this，当前变量）</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">同步代码块</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Lock</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">ReentrantLock类&lt;br&gt;</span><span class="s2"> 
      </span><span class="s0">  - </span><span class="s1">基于CAS的，性能好</span><span class="s2"> 
      </span><span class="s0">  - </span><span class="s1">通过lock.lock和lock.unlock来获取锁和释放锁，功能可以替代synchronized</span><span class="s2"> 
      </span><span class="s0">  - </span><span class="s1">可实现condition的信号通知，生产者消费者模式</span><span class="s2"> 
      </span><span class="s0">  - </span><span class="s1">内部实现了公平锁与非公平锁</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">ReadWriteLock接口</span><span class="s2"> 
      </span><span class="s0">  - </span><span class="s1">ReentrantReadWriteLock类&lt;br&gt;</span><span class="s2"> 
        </span><span class="s1">读锁可以有很多个锁同时上锁，只要当前没有写锁；  </span><span class="s2"> 
        </span><span class="s1">写锁是排他的，上了写锁，其他线程既不能上读锁，也不能上写锁；同样，需要上写锁的前提是既没有读锁，也没有写锁；  </span><span class="s2"> 
        </span><span class="s1">两个写锁不能同时获得，下面一段程序说明下上了读锁以后，其他线程需要上写锁也无法获得 </span><span class="s2"> 
        </span><span class="s1">如果你已经有了读锁，再去试图获得写锁，将会无法获得， 一直堵住了；  </span><span class="s2"> 
        </span><span class="s1">但是如果你有了写锁，再去试图获得读锁，没问题；  </span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">CountDownLatch类&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">通常的使用场景是，某个主线程接到一个任务，起了n个子线程去完成，但是主线程需要等待这n个子线程都完成任务了以后才开始执行某个操作</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">Semaphore信号量机制&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">Semaphore可以控制某个资源可被同时访问的个数，通过 acquire</span><span class="s2">()</span><span class="s1"> 获取一个许可，如果没有就等待，而 release</span><span class="s2">()</span><span class="s1"> 释放一个许可</span><span class="s2"> 
</span><span class="s0">###</span><span class="s1">synchronized和Lock的区别</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">1，没有获取锁时，进入状态不一样，blocked waiting</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">2，被唤醒时的机制不一样，synchronized由JVM调度器来唤醒，waiting状态由另一个线程来显式唤醒notify/notifyAll</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">3，实现机制不同，synchronized由JVM实现的，Lock由AQS来实现的</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">4，使用场景也不同，synchronized互斥锁，Lock不仅实现互斥锁，还有可重入锁</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">说下AQS原理</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">线程池有哪些类型？内部是怎样实现的</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Executors.newSingleThreadExecutor</span><span class="s2">()</span><span class="s1">&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">核心线程数、最大线程数都为1</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Executors.newFixedThreadPool</span><span class="s2">()</span><span class="s1">&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">核心线程数、最大线程数都为固定值</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Executors.newScheduledThreadPool</span><span class="s2">()</span><span class="s1">&lt;br&gt;</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Executors.newCachedThreadPool</span><span class="s2">()</span><span class="s1">&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">核心线程数为0，最大线程数为integer.MAX_VALUE，线程等待60s无任务时会被移除&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">public ThreadPoolExecutor</span><span class="s2">(</span><span class="s1">int corePoolSize,&lt;br&gt;</span><span class="s2"> 
                          </span><span class="s1">int maximumPoolSize,&lt;br&gt;</span><span class="s2"> 
                          </span><span class="s1">long keepAliveTime,&lt;br&gt;</span><span class="s2"> 
                          </span><span class="s1">TimeUnit unit,&lt;br&gt;</span><span class="s2"> 
                          </span><span class="s1">BlockingQueue&lt;Runnable&gt; workQueue,&lt;br&gt;</span><span class="s2"> 
                          </span><span class="s1">ThreadFactory threadFactory,&lt;br&gt;</span><span class="s2"> 
                          </span><span class="s1">RejectedExecutionHandler handler</span><span class="s2">) </span><span class="s1">//后两个参数为可选参数</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">说下ThreadLocal的原理及使用场景</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">理解ThreadLocal重要的点是</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">1，每个Thread类里都有一个容器（ThreadLocal.ThreadLocalMap），这个容器只供线程自己使用，ThreadLocal都是对当前线程的这个容器的操作</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">2，ThreadLocal.get</span><span class="s2">()</span><span class="s1">，先判断当前线程是否有容器，没有先创建个设置默认值的容器，有的话就返回</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">3，ThreadLocal.set</span><span class="s2">()</span><span class="s1">，是设置当前线程的容器的值，每个线程均有一个容器</span><span class="s2"> 
 
</span><span class="s1">ThreadLocal解决什么问题呢？</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">把变量放到ThreadLocal里面&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">实际应用，说下使用AOP解决读写分离数据库时，动态改变数据源时，使用ThreadLocal解决多数据源</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">把方法放到ThreadLocal里面&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">（DateUtil2_1类中有实现）比如一个线程不安全的类，SimpleDateFormat，2个线程同时访问时，可能会出现问题，解决方法有两个，一个方法是用synchronized，使方法串行访问；另一个是用ThreadLocal包装SimpleDateFormat类，这样在每一个线程的容器里都有一个SimpleDateFormat的副本，每个线程可以使用它自己容器里面的SimpleDateFormat方法，也就不会有并发问题了。</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">ConcurrentHashMap加锁机制是什么，详细说一下？</span><span class="s2"> 
   </span><span class="s1">HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，</span><span class="s2"> 
   </span><span class="s1">那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，</span><span class="s2"> 
   </span><span class="s1">然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">volatile和synchronized区别</span><span class="s2"> 
</span><span class="s0">-    </span><span class="s1">1）volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</span><span class="s2"> 
</span><span class="s0">-    </span><span class="s1">2）volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</span><span class="s2"> 
</span><span class="s0">-    </span><span class="s1">3）volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.</span><span class="s2"> 
</span><span class="s0">-    </span><span class="s1">4）volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</span><span class="s2"> 
 
</span><span class="s0">#</span><span class="s1">Spring</span><span class="s2"> 
</span><span class="s0">###</span><span class="s1">Spring事务默认配置下，没有使用事务的方法，调用使用了事务的方法，事务会生效吗？</span><span class="s2"> 
</span><span class="s1">不会&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">1，Spring事务帮我们做了什么 2，反射，方法是否有@Transaction注解 3，有注解时，没有注解时</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">Bean的生命周期的整个过程</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">IOC有哪些常用的注解</span><span class="s2"> 
(</span><span class="s1">@Configuration</span><span class="s2">)</span><span class="s1">注解表明此类为配置类，包含了Spring应用上下文中如何创建bean的细节；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Bean</span><span class="s2">)</span><span class="s1">注解表明该方法会返回一个对象，并需要将其注册为Spring应用上下文中的bean，并且可以在方法中完成依赖注入；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Component</span><span class="s2">)</span><span class="s1">注解表明该类会作为组件类，并告知Spring要为此类创建bean；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@ComponentScan</span><span class="s2">(</span><span class="s1">packName</span><span class="s2">))</span><span class="s1">注解表明在指定包下扫描带有Component注解的类，并为其创建bean；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@AutoWired</span><span class="s2">)</span><span class="s1">注解申明了依赖，自动装配，可以用于属性和set方法；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Import</span><span class="s2">(</span><span class="s1">xxx.class</span><span class="s2">))</span><span class="s1">注解将括号中声明的JAVA配置类导入当前配置类；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@ImportResource</span><span class="s2">(</span><span class="s1">classpath</span><span class="s2">:</span><span class="s1">xxx.xml</span><span class="s2">))</span><span class="s1">注解将括号中声明的XML配置导入当前配置类；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Profile</span><span class="s2">())</span><span class="s1">注解表明只有此Profile激活时</span><span class="s2">(</span><span class="s1">配置spring.profile.active和spring.profile.default</span><span class="s2">)</span><span class="s1">，此Bean才会被创建，没有Profile注解的总是会被创建；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Conditional</span><span class="s2">(</span><span class="s1">? implents Condition</span><span class="s2">))</span><span class="s1">注解表明只有给定条件计算结果为true时才会创建bean，可以用于带@Bean注解的方法上，括号内为实现了Condition接口的类；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Primary</span><span class="s2">)</span><span class="s1">当匹配的Bean不止一个时，此注解可以设置首选，避免自动装配时的歧义性；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Qualifier</span><span class="s2">)</span><span class="s1">注解使用限定符，在可选Bean上缩小范围最终达到只有1个Bean满足所规定的限制条件；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Scope</span><span class="s2">)</span><span class="s1">注解声明了bean的作用域；proxyMode属性设置作用域代理，代理对bean进行懒解释并将调用委托给会话/请求作用域内真正的bean；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Aspect</span><span class="s2">)</span><span class="s1">注解表明该类是一个切面；&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　-</span><span class="s2">(</span><span class="s1">@Pointcut</span><span class="s2">)</span><span class="s1">注解表明在一个@Aspect切面内定义可重用的切点&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　-</span><span class="s2">(</span><span class="s1">@After</span><span class="s2">)</span><span class="s1">注解表明通知方法会在目标方法返回或抛出异常后调用；&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　-</span><span class="s2">(</span><span class="s1">@AfterReturning</span><span class="s2">)</span><span class="s1">注解表明通知方法会在目标方法返回后调用；&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　-</span><span class="s2">(</span><span class="s1">@AfterThrowing</span><span class="s2">)</span><span class="s1">注解表明通知方法会在目标方法抛出异常后调用；&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　-</span><span class="s2">(</span><span class="s1">@Around</span><span class="s2">)</span><span class="s1">注解表明通知方法会将目标方法封装起来；该通知方法需要接受ProceedingJoinPoint作为参数，通过它来调用被通知的方法，当要将控制权交给被通知方法时，需要调用它的proceed方法；&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　-</span><span class="s2">(</span><span class="s1">@Before</span><span class="s2">)</span><span class="s1">注解表明通知方法会在目标方法调用之前执行；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@EnableWebMvc</span><span class="s2">)</span><span class="s1">启用Spring MVC；&lt;br/&gt;</span><span class="s2"> 
(</span><span class="s1">@Controller</span><span class="s2">)</span><span class="s1">声明一个控制器，基于@Componet注解，辅助实现组件扫描；&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　-</span><span class="s2">(</span><span class="s1">@RequetsMapping</span><span class="s2">)</span><span class="s1">注解声明了它们所要处理的请求，可以在类和方法上声明；&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　　　　　</span><span class="s2">(</span><span class="s1">@RequestParam</span><span class="s2">)  </span><span class="s1">&lt;br/&gt;</span><span class="s2"> 
</span><span class="s1">　　　　　　　</span><span class="s2">(</span><span class="s1">@PathVariable</span><span class="s2">)</span><span class="s1">&lt;br/&gt;</span><span class="s2"> 
 
</span><span class="s1">说下BeanFactoryPostProcesser、BeanPostProcesser  </span><span class="s2"> 
 
</span><span class="s0">#</span><span class="s1">Spring Boot</span><span class="s2"> 
 
</span><span class="s0">#</span><span class="s1">Spring MVC</span><span class="s2"> 
</span><span class="s0">#</span><span class="s1">MySql</span><span class="s2"> 
</span><span class="s0">###</span><span class="s1">数据库优化</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">表的建立要满足三范式</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">字段的选择</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">数字类型时</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">字符类型时</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">时间类型时</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">字符编码会影响数据库占用空间</span><span class="s2"> 
    </span><span class="s1">UTF-8：一个汉字 = 3个字节，英文是一个字节&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">GBK： 一个汉字 = 2个字节，英文是一个字节</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">sql优化</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">只返回需要的数据（字段，where）</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">join代替子查询</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">建立索引</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">索引的使用</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">什么样的sql不走索引 </span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">什么样的字段需要建立索引</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">组合索引 是否使用索引使用explair关键字查看</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">存储过程的使用</span><span class="s2"> 
    </span><span class="s1">表到表的数据移动</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">锁的使用</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">乐观锁</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">悲观锁     </span><span class="s2"> 
</span><span class="s1">系统层面</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">使用Redis缓存，减少数据库访问</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">读写分离，将数据分开读写，提升性能</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">分库分表</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">MyISAM、InnoDB区别</span><span class="s2"> 
</span><span class="s1">l MyISAM类型不支持事务，而InnoDB类型支持。</span><span class="s2"> 
</span><span class="s1">l MyISAM表不支持外键，InnoDB支持</span><span class="s2"> 
</span><span class="s1">l MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</span><span class="s2"> 
</span><span class="s1">l MyISAM支持全文类型索引，而InnoDB不支持全文索引。</span><span class="s2">(</span><span class="s1">mysql 5.6后innodb支持全文索引</span><span class="s2">) 
</span><span class="s1">MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。当你的数据库有大量的写入、更新操作而查询比较少，数据完整性要求比较高的时候就选择innodb表。当你的数据库主要以查询为主，相比较而言更新和写 入比较少，并且业务方面数据完整性要求不那么严格，就选择mysiam表。</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">数据库隔离级别</span><span class="s2"> 
</span><span class="s1">1）Serializable </span><span class="s2">(</span><span class="s1">串行化</span><span class="s2">)</span><span class="s1">：可避免脏读、不可重复读、幻读的发生。</span><span class="s2"> 
</span><span class="s1">2）Repeatable read </span><span class="s2">(</span><span class="s1">可重复读</span><span class="s2">)</span><span class="s1">：可避免脏读、不可重复读的发生。</span><span class="s2"> 
</span><span class="s1">3）Read committed </span><span class="s2">(</span><span class="s1">读已提交</span><span class="s2">)</span><span class="s1">：可避免脏读的发生。</span><span class="s2"> 
</span><span class="s1">4）Read uncommitted </span><span class="s2">(</span><span class="s1">读未提交</span><span class="s2">)</span><span class="s1">：最低级别，任何情况都无法保证。</span><span class="s2"> 
 
 
</span><span class="s0">###</span><span class="s1">数据库如何实现rollback的？</span><span class="s2"> 
</span><span class="s1">数据库在写入数据之前是先讲对数据的改动写入 redo log 和 undo log，然后在操作数据，如果成功提交事务就会把操作写入磁盘；&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">如果失败就会根据redo log和undo log逆向还原到事务操作之前的状态。&lt;br&gt;</span><span class="s2"> 
 
 
</span><span class="s0">#</span><span class="s1">Redis</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">redis支持哪些数据结构。</span><span class="s2"> 
</span><span class="s1">支持5种数据类型&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">String&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">Hash &lt;/b&gt;</span><span class="s2"> 
![</span><span class="s1">线程状态转换</span><span class="s2">](</span><span class="s1">images/Redis的Hash.jpg</span><span class="s2">)</span><span class="s1">&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">hset key field fieldvalue&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">hget key field&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">hgetall key&lt;/b&gt;</span><span class="s2"> 
 
</span><span class="s1">List&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">有序的，可重复的</span><span class="s2"></span><span class="s1">消息队列，缓冲队列&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">Set&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">无序的，不可重复的，可以求两个set的交集，并集，差集&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">Sets 集合的概念就是一堆不重复值的组合。利用Redis提供的Set数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">Sorted set &lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">有序的set，插入的数据自动有序&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级</span><span class="s2">(</span><span class="s1">score</span><span class="s2">)</span><span class="s1">的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。&lt;/b&gt;</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">redis为什么是单线程的</span><span class="s2"> 
</span><span class="s1">因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">redis的性能，普通服务器可以处理几万到十几万的请求，如果有几十万的并发，可以考虑cluster集群模式。&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">万一CPU成为Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？&lt;/b&gt;</span><span class="s2"> 
</span><span class="s1">那也很简单，你多起几个Redis进程就好了。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。</span><span class="s2"> 
</span><span class="s1">只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好。&lt;br&gt;</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">Redis单线程模型是什么 </span><span class="s2"> 
</span><span class="s1">Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。</span><span class="s2"> 
</span><span class="s1">其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。</span><span class="s2"> 
</span><span class="s1">并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">Redis为什么这么快</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">1）绝大部分请求是纯粹的内存操作（非常快速）</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">2）采用单线程,避免了不必要的上下文切换和竞争条件</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">3）采用IO多路复用模型</span><span class="s2"> 
</span><span class="s1">这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">Redis采用非阻塞的I/O多路复用技术，可以使用单个Redis线程高效的处理多个客户端连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据，速度非常快&lt;br&gt;</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">一个key值如何在redis集群中找到存储在哪里。 </span><span class="s2"> 
</span><span class="s1">一个Redis集群总共有16384个slot槽，比如有三个节点，意味着这三个接点要占满这些slot，看图：</span><span class="s2"> 
![</span><span class="s1">线程状态转换</span><span class="s2">](</span><span class="s1">images/查找redis的key在哪一台.png</span><span class="s2">)</span><span class="s1">&lt;/b&gt;</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">redis持久化策略</span><span class="s2"> 
</span><span class="s1">RDB （RedisDataBase）</span><span class="s2"> 
</span><span class="s1">AOF </span><span class="s2">(</span><span class="s1">append only log</span><span class="s2">) 
</span><span class="s1">采用RDB机制时，当使用save, shutdown, slave 命令时会触发这个操作，Redis会fork一个进程，把整个db 在这一时间点的快照dump保存下来。恢复时，只会恢复这一时间点的数据，时间点后的数据不会恢复，粒度大</span><span class="s2"> 
</span><span class="s1">采用AOF机制时，每次写操作指令，都会持续写到一个日志文件里。（类似于从postgresql等数据库导出sql一样，只记录写操作），crash后利用这日志恢复数据，粒度较小，只有crash之前没有来得及做日志的操作没办法恢复。</span><span class="s2"> 
</span><span class="s1">选择的标准，如果系统愿意牺牲一些性能，换取更高的缓存一致性，使用AOF；如果系统性能要求特别高，写操作非常频繁，缓存数据一致性要求又不太高，使用RDB</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">redis的部署方式，主从，集群</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">redis的哨兵模式</span><span class="s2"> 
 
 
</span><span class="s0">#</span><span class="s1">MyBatis</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">Mybaits中#和$区别</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">1）${}是Properties文件中的变量占位符，有可能会引起sql注入</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">2）#{}是sql的“参数占位符”，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，</span><span class="s2"> 
</span><span class="s1">比如ps.setInt</span><span class="s2">(</span><span class="s1">0, parameterValue</span><span class="s2">)</span><span class="s1">，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem</span><span class="s2">()</span><span class="s1">.getName</span><span class="s2">()</span><span class="s1">。</span><span class="s2"> 
 
</span><span class="s0">#</span><span class="s1">队列</span><span class="s2"> 
 
</span><span class="s0">#</span><span class="s1">JVM</span><span class="s2"> 
</span><span class="s0">###</span><span class="s1">JVM内存模型</span><span class="s2"> 
</span><span class="s1">JMM Java内存模型是一种规范，解决多线程通过共享内存进行通信时，各个线程的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">作用：JMM就作用于工作内存和主存之间数据同步过程。它规定了如何做数据同步以及什么时候做数据同步，</span><span class="s2"> 
</span><span class="s1">目的是保证并发编程场景中的原子性、可见性和有序性。&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">Java语言对内存模型的实现&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">在 Java 中提供了一系列和并发处理相关的关键字，比如 Volatile、Synchronized、Final、Concurren 包等。&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">用volatile修饰之后：</span><span class="s2"> 
</span><span class="s0">-   </span><span class="s1">第一：使用volatile关键字会强制将修改的值立即写入主存；</span><span class="s2"> 
</span><span class="s0">-   </span><span class="s1">第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</span><span class="s2"> 
</span><span class="s0">-   </span><span class="s1">第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">JVM的内存结构</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">程序计数器：线程私有。</span><span class="s2"> 
</span><span class="s1">是一块较小的内存，是当前线程所执行的字节码的行号指示器。是Java虚拟机规范中唯一没有规定OOM（OutOfMemoryError）的区域。</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Java栈：线程私有。</span><span class="s2"> 
</span><span class="s1">生命周期和线程相同。&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">执行每个方法都会创建一个栈帧，用于存储存放局部变量表，操作数栈，动态链接，方法出口。&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">局部变量所需要的内存空间大小在编译期间完成分配。所以栈帧的大小不会改变。&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">存在两种异常情况：若线程请求深度大于栈的深度，抛StackOverflowError。若栈在动态扩展时无法请求足够内存，抛OOM。&lt;br&gt;</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Java堆：所有线程共享。虚拟机启动时创建。存放对象实例和数组。所占内存最大。分为新生代（Young区），老年代（Old区）。新生代分Eden区，Servior区。Servior区又分为From space区和To Space区。Eden区和Servior区的内存比为8</span><span class="s2">:</span><span class="s1">1。 当扩展内存大于可用内存，抛OOM。</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">方法区：所有线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。又称为非堆（Non – Heap）。方法区又称“永久代”。GC很少在这个区域进行，但不代表不会回收。</span><span class="s2"> 
</span><span class="s1">这个区域回收目标主要是针对常量池的回收和对类型的卸载。当内存申请大于实际可用内存，抛OOM。</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">本地方法栈：线程私有。与Java栈类似，但是不是为Java方法（字节码）服务，而是为本地非Java方法服务。也会抛StackOverflowError和OOM。</span><span class="s2"> 
</span><span class="s0">###</span><span class="s1">JVM的参数</span><span class="s2"> 
![</span><span class="s1">线程状态转换</span><span class="s2">](</span><span class="s1">images/jvm参数.png</span><span class="s2">)</span><span class="s1">&lt;/b&gt;</span><span class="s2"> 
 
 
</span><span class="s0">###</span><span class="s1">可以被作为GC Roots的对象</span><span class="s2"> 
</span><span class="s0">-   </span><span class="s1">1.栈中引用的对象</span><span class="s2"> 
        </span><span class="s1">- A a = new A</span><span class="s2">()</span><span class="s1">;//满足栈中的引用的对象</span><span class="s2"> 
</span><span class="s0">-   </span><span class="s1">2.方法区中“类变量”引用的对象</span><span class="s2"> 
        </span><span class="s1">- static int a=1 静态属性在方法区</span><span class="s2"> 
</span><span class="s0">-   </span><span class="s1">3.方法区中“常量”引用的对象</span><span class="s2"> 
        </span><span class="s1">- final int a=1;常量 在方法区</span><span class="s2"> 
        </span><span class="s1">- final String a=</span><span class="s2">&quot;</span><span class="s1">abc</span><span class="s2">&quot;</span><span class="s1">;常量 在方法区</span><span class="s2"> 
        </span><span class="s1">- final Object obj=new Object</span><span class="s2">()</span><span class="s1">；对象分配在堆上，变量obj分配在方法区，final修饰的obj，表示obj所指的引用不可变</span><span class="s2"> 
</span><span class="s0">-   </span><span class="s1">4.本地方法栈中Native方法（JNI</span><span class="s2">: </span><span class="s1">Java Native Interface）引用的对象</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">年轻代 标记复制算法会不会STW？为什么</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">Minor GC ，Full GC 触发条件</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Minor GC触发条件：当Eden区满时，触发Minor GC。</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">Full GC触发条件：</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">（1）调用System.gc时，系统建议执行Full GC，但是不必然执行</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">（2）老年代空间不足</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">（3）方法区空间不足</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">（4）通过Minor GC后进入老年代的大小大于老年代的可用内存</span><span class="s2"> 
  </span><span class="s0">  - </span><span class="s1">（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</span><span class="s2"> 
 
 
</span><span class="s0">#</span><span class="s1">设计模式</span><span class="s2"> 
</span><span class="s0">###</span><span class="s1">建造者模式</span><span class="s2"> 
 
</span><span class="s0">#</span><span class="s1">分布式系统常见问题</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">分布式事务怎样处理的？</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">两阶段提交</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">拆分为两个本地事务进行</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">使用RocketMQ</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">TCC</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">后台怎样防止两次重复的请求？</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">如果是update数据库可以不用管，如果是set Redis也可以不用管，查询也不用管</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">利用数据库唯一性索引</span><span class="s2"> 
    </span><span class="s0">1. </span><span class="s1">服务器A接收到请求之后,对请求信息hash运算,得到hash值hashCodeA;&lt;br&gt;</span><span class="s2"> 
    </span><span class="s0">2. </span><span class="s1">保存hashCodeA 到数据库,相应的列</span><span class="s2">(</span><span class="s1">column</span><span class="s2">)</span><span class="s1">做unique约束;&lt;br&gt;</span><span class="s2"> 
    </span><span class="s0">3. </span><span class="s1">保存成功之后,才进行正常业务逻辑处理,比如提交订单;&lt;br&gt;</span><span class="s2"> 
    </span><span class="s0">4. </span><span class="s1">服务器B接收到相同的请求后,也得到相同的hash值,hashCodeA,&lt;br&gt;</span><span class="s2"> 
    </span><span class="s0">5. </span><span class="s1">服务器B 保存hashCodeA 到数据库,肯定失败,因为相同的hash值已经存在;&lt;br&gt;</span><span class="s2"> 
    </span><span class="s0">6. </span><span class="s1">因为保存失败,所以后面的业务逻辑不会执行.&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">缺点：如果hash保存到库，还没有开始处理请求，这时数据库挂了，重启以后hash已经保存到库，这时再重发请求，这笔请求就不会处理&lt;br&gt;</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">结合前端处理</span><span class="s2"> 
</span><span class="s1">请求页面，服务器后端生成token并保存到redis，并把token返回到前端&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">用户post请求时带上token，后端收到请求，先去redis中查找，如果存在这个token，先处理请求，然后删掉这个token&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">这样后面重发的请求，去redis查找，发现不存在，就不去处理&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">缺点：需要前端配合，不灵活&lt;br&gt;</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">想想为什么要使用MQ</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">1.解耦，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">2.异步，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">3.削峰，并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">MQ如果丢包的话怎么办？</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">生产者丢包</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">队列丢包</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">消费者丢包</span><span class="s2"> 
    </span><span class="s1">①自动确认模式&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">消费者挂掉或异常了，队列收不到ack时，会重回到队列，消息会不断的被重发，直到处理成功，所以不会丢失消息。&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">②手动确认模式&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">如果消费者来不及处理就死掉时，没有响应ack时，队列会重复发送一条信息给其他消费者；&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息</span><span class="s2">(</span><span class="s1">重试机制</span><span class="s2">)</span><span class="s1">。&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">③不确认模式&lt;br&gt;</span><span class="s2"> 
    </span><span class="s1">acknowledge=</span><span class="s2">&quot;</span><span class="s1">none</span><span class="s2">&quot; </span><span class="s1">不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。&lt;br&gt;</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">MQ如何保证消息的顺序性？</span><span class="s2"> 
</span><span class="s1">要实现严格的顺序消息，简单且可行的办法就是：保证 生产者 - queue - 消费者是一对一对一的关系&lt;br&gt;</span><span class="s2"> 
</span><span class="s1">这样的设计虽然简单易行，但也会存在一些很严重的问题，比如：&lt;br&gt;</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">1、并行度就会成为消息系统的瓶颈（吞吐量不够）</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">2、更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。但我们的最终目标是要集群的高容错性和高吞吐量</span><span class="s2"> 
</span><span class="s1">RabbitMQ&lt;br&gt;</span><span class="s2"> 
![</span><span class="s1">线程状态转换</span><span class="s2">](</span><span class="s1">images/rabbitmq消息顺序.png</span><span class="s2">) 
</span><span class="s1">把有序的消息按同一规则（对唯一标识进行 hash），有顺序的放入一个 queue 里面，一个queue只对应一个消费者，消费者只取一个 queue的数据，这样执行的顺序是有序的。&lt;br&gt;</span><span class="s2"> 
 
 
</span><span class="s0">###</span><span class="s1">幂等概念有没有了解过</span><span class="s2"> 
</span><span class="s1">幂等性是数学上的含义是对于参数 x，f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span><span class="s1">=f</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span><span class="s1">;比如绝对值函数。 &lt;br&gt;</span><span class="s2"> 
</span><span class="s1">在分布式环境下表示的是对于同样的请求，在一次或者多次请求的情况下对系统的使用资源是一样的，保证失败重试不会导致提交两次。 方法：带版本号的方式； 采用数据库唯一索引方式；&lt;br&gt;</span><span class="s2"> 
 
</span><span class="s0">#</span><span class="s1">大赛系统</span><span class="s2"> 
 
</span><span class="s0">#</span><span class="s1">开放式问题</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">cpu很高 怎样排查</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">1，jps -l 得到pid</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">2，jstack pid </span><span class="s2">&gt;&gt; </span><span class="s1">file.txt 导出CPU占用高进程的线程栈</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">3，top -H -p PID 查看对应进程的哪个线程占用CPU过高</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">4，echo </span><span class="s2">&quot;</span><span class="s1">obase=16; PID</span><span class="s2">&quot; </span><span class="s1">| bc  将线程的PID转换为16进制,大写转换为小写</span><span class="s2"> 
</span><span class="s0">- </span><span class="s1">5，在第二步导出的Java.txt中查找转换成为16进制的线程PID。找到对应的线程栈信息，找到对应的代码行</span><span class="s2"> 
 
 
</span><span class="s0">###</span><span class="s1">工作这么久你遇到的最难的技术点是什么？</span><span class="s2"> 
</span><span class="s1">我这边根据具体的工具经理，回答的是 kafka 的初次使用，因为当时是公司内部第一个引入 kafka，之前没有小组使用过，所以要采很多坑。并且那个时候 kafka 还没有发布1.0版本，官网和网上提供的版本很杂乱不兼容。</span><span class="s2"> 
 
</span><span class="s0">###</span><span class="s1">你自己认为自己最熟悉的技术是什么？</span><span class="s2"> 
   </span><span class="s1">java语言 多线程计算 </span><span class="s2"> 
   </span><span class="s1">Spring Boot</span><span class="s2"> 
   </span><span class="s1">消息队列的使用</span><span class="s2"> 
   </span><span class="s1">Redis</span><span class="s2"> 
 
 
 
 
</span></pre>
</body>
</html>